import state, graphics, globals, process, clone, utils, text;

struct TerminalResult {
    bool successful;
    str text;

    void constructor(bool successful, str text = "") {
        self.successful = successful;
        self.text = text;
    }
}

struct TerminalCommand {
    str path;

    void constructor(str path = "") {
        self.path = path;
    }

    TerminalResult execute(Arr<str> args) {
        Process proc = 
        return new TerminalResult(true);
    }
}

struct TerminalTheme {
    str text = "#fff";
    str warn = "#e37900";
    str error = "#bf0000";
}

struct TerminalContext {
    State state;

    Obj<TerminalCommand> commands;

    void constructor(State state, Obj<TerminalCommand> commands = {}) {
        self.state = state;
        self.commands = commands;
    }

    void registerCommand(str id, TerminalCommand command) {
        self!.commands[id] = command;
    }
}

struct TerminalInstance {
    str text = "> ";
    str currentCmd = "";

    Process process;
    TerminalContext context;
    TerminalTheme theme = new TerminalTheme();

    void constructor(TerminalContext context) {
        self.context = context;
    }

    str _destr(str value) {
        if (value[0] == "\"" && value[value.length - 1] == "\"") {
            return value.slice(1,-1);
        }
        print(value);
        return value;
    }
    TerminalResult runCommand(str cmd) {
        Arr<str> tokens = utils:splitChar(cmd, " ", ["intactQuotes"]);
        
        Arr<str> k = self.context.commands.keys();
        if (k.contains(tokens[0])) {
            Arr<str> args = [];
            str key = tokens.shift();
            for (i, tokens.length) {
                elem = tokens[i];
                args.append(self._destr(elem).toString());
            }
            TerminalCommand command = self.context.commands[key];
            return command.execute(args);
        }

        return new TerminalResult(false, "unknown command \'" ++ tokens[0] ++ "\'");
    }
}

void init(State state, GraphicsState graphicsState) {
    graphicsState.drawSurface.loadFontFromUrl(state.config.fontUrl);
    globals:setGlobal<TerminalContext>("terminalContext", new TerminalContext(state, {
        "echo": new TerminalCommand("echo")
    }));

    TerminalContext context = globals:getGlobal<TerminalContext>("terminalContext");
    globals:setGlobal<TerminalInstance>("terminalInstance", new TerminalInstance(context));
}

void runCommand(str cmd, TerminalInstance termInstance) {
    TerminalResult result = termInstance.runCommand(cmd);

    if (!result.successful) {
        termInstance.text ++= text:embedColor(termInstance.context.state, termInstance.theme.warn);
    }
    termInstance.text ++= result.text;
}
void newLine(TerminalInstance termInstance) {
    if (termInstance.text.length > 0) {
        termInstance.text ++= "\n";
    }
    termInstance.text ++= text:embedReset(termInstance.context.state);
    termInstance.text ++= "> ";
}

void handleInput(State state) {
    TerminalInstance termInstance = globals:getGlobal<TerminalInstance>("terminalInstance");
    
    bool inControl = true;
    if (termInstance?.process) {
        proc = termInstance!.process;
    }

    Arr<str> keys = state.inputState.map.keys;
    while (keys.length > 0) {
        str key = keys.pop();
        if (inControl) {
            termInstance.text ++= key;
            termInstance.currentCmd ++= key;
        }
    }

    Arr<str> special = state.inputState.map.special;
    while (special.length > 0) {
        str key = special.pop();
        if (inControl) {
            if (key == "Enter" && termInstance.currentCmd.length > 0) {
                termInstance.text ++= "\n";
                runCommand(termInstance.currentCmd, termInstance);
                newLine(termInstance);
                termInstance.currentCmd = "";
            }
            if (key == "Backspace" && termInstance.currentCmd.length > 0) {
                termInstance.text = termInstance.text.slice(0,-1);
                termInstance.currentCmd = termInstance.currentCmd.slice(0,-1);
            }
        }
    }
    globals:setGlobal<TerminalInstance>("terminalInstance", termInstance);
}

void drawMain(State state, GraphicsState graphicsState) {
    Surface drawSurf = graphicsState.drawSurface;
    Frame drawFrame = drawSurf.frame;
    TerminalInstance termInstance = globals:getGlobal<TerminalInstance>("terminalInstance");
    
    /* draw background */ {
        drawSurf.setColor("#0e0d10");
        drawSurf.rect(drawFrame.getX(), drawFrame.getY(), drawFrame.getW(), drawFrame.getH(), 0);
    }
    // what
    /* textbox */ {
        drawSurf.setColor("#fff");
        Arr<num> pos = drawFrame.getTL();
        drawSurf.text(termInstance.text, 10, pos[0] + 5, pos[1] - 17.5);
    }
}

void update(State state, GraphicsState graphicsState) {
    handleInput(state, graphicsState);
    drawMain(state, graphicsState);
}